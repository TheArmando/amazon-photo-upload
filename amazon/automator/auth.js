const fs = require('fs');

const AMAZON_SIGNIN_URL = 'https://www.amazon.com/ap/signin';
const AMAZON_PHOTOS_URL = 'https://www.amazon.com/photos/all';

const EMAIL_ATTRIBUTE = '[type=email]';
const PASSWORD_ATTRIBUTE = '[type=password]';
const LOGIN_ATTRIBUTE = '[type=submit]';

const COOKIES_FILENAME = 'cookies.json';
const HEADERS_FILENAME = 'headers.json';
const DEBUG_DIR = './debug/'
const SCREENSHOT_FILENAME = 'screenshot.png';

const ONE_SECOND_IN_MS = 1000;

const isAtLoginScreen = (url) => url.startsWith(AMAZON_SIGNIN_URL);
const isAtPhotosScreen = (url) => url.startsWith(AMAZON_PHOTOS_URL);

const sleep = (millis) => new Promise((resolve) => setTimeout(resolve, millis));

const INPUT_DELAY_IN_MILLISECONDS = 50;
const delayTime = () => Math.floor(Math.random() * INPUT_DELAY_IN_MILLISECONDS);

// TODO: might move this somewhere else
const loadCredentials = () => {
  if (fs.existsSync('./' + CREDENTIALS_FILENAME)) {
    const data = JSON.parse(fs.readFileSync('./' + CREDENTIALS_FILENAME, { encoding: 'utf8' }));
    if (!username || !password) {
      console.log('No credentials found - set credentials and rerun the application');
      exit(1);
    }    
    return {
      username: data.username,
      password: data.password
    }
  } else {
    const data = JSON.stringify({ username: '', password: '' });
    fs.writeFileSync('./' + CREDENTIALS_FILENAME, data);
    console.log('No credentials found - set credentials and rerun the application');
    exit(1);
  }
};

module.exports = class Authentication {
  constructor(page, isDebug) {
    this.page = page;
    this.isDebug = isDebug;
    this.didInitialization = false;
    this.credentials = loadCredentials();
  }

  // if not logged in amazon should redirect us to the login page after attempting to navigate to the photos page
  async isLoggedIn() {
    await this.page.goto(AMAZON_PHOTOS_URL);
    if (isAtPhotosScreen(this.page.url)) {
      return true;
    }
    return false;
  }

  async init() {
    await this.#loadCookiesFromFile();
    // Setup request interception to required authentication data like session id and cookies
    this.cdpRequestDataRaw = await this.#setupLoggingOfAllNetworkData();
    this.didInitialization = true;
  }

  // get the saved request headers needed to do API requests to Amazon photos
  getHeaders() {
    this.headers = {};
    for (const [requestID, entry] of Object.entries(this.cdpRequestDataRaw)) {
      if (entry['Network.requestWillBeSent'] && entry['Network.requestWillBeSent'].request.url.startsWith('https://www.amazon.com/drive/v1/search')) {
        const h = entry['Network.requestWillBeSentExtraInfo'].headers;
        for (const [header, value] of Object.entries(h)) {
          // some headers are prefixed with ':' indicating that they're autogenerated. These are set are set per request to facilitate the underlying http call
          if (!header.startsWith(':')) {
            this.headers[header] = value;
          }
        }
      }
    }
    if (this.isDebug) {
      console.log('headers', this.headers);
    }
    fs.writeFileSync('./' + HEADERS_FILENAME, JSON.stringify(headers, null, 4));
    return this.headers;
  }

  // for development & debugging, still don't know if this timestamp is the expiry date or issue date
  findCookieExpirationDate() {
    this.headers = this.getHeaders();
    const cookies = this.headers['cookie'];
    const cookieToLookFor = 'csm-hit';
    if (cookies.includes(cookieToLookFor)) {
      const foundCookie = cookies.slice(cookies.indexOf(cookieToLookFor));
      const timestampIndicator = '&t:';
      const startOfTimestamp = foundCookie.slice(foundCookie.indexOf(timestampIndicator)+timestampIndicator.length);
      const timestamp = startOfTimestamp.slice(0, startOfTimestamp.indexOf('&'));
      return new Date(parseInt(timestamp));
    }
  }

  async login() {
    if (!this.didInitialization) {
      await this.init();
    }
    if (!(await this.isLoggedIn())) {
      const timeWhenLoginStarted = Date.now();
      await this.#fillCredentialsAndLogin(this.credentials.username, this.credentials.password);
      // TODO: if debug flag is on?
      // continuallyTakeScreenshots()
      while (!isAtPhotosScreen(this.page.url)) {
        await this.#checkForWarningMessage();
        await sleep(ONE_SECOND_IN_MS);
        if (Date().now() - timeWhenLoginStarted > 10 * ONE_SECOND_IN_MS) {
          console.log(`${10} seconds elapsed since submitting login information`);
        }
      }
    } else {
      console.warn('login procedure was skipped, youre probably already logged in');
    }
  }

  async #fillCredentialsAndLogin(username, password) {
    // check if email text box is on page. could be missing if amazon remembers the user
    if (await this.page.$(EMAIL_ATTRIBUTE) != null) {
      await this.page.type(EMAIL_ATTRIBUTE, username, { delay: delayTime() });
    }
  
    await this.page.type(PASSWORD_ATTRIBUTE, password, { delay: delayTime() });
    await Promise.all([
      this.page.waitForNavigation(),
      this.page.click(LOGIN_ATTRIBUTE, { delay: delayTime() }),
    ]);
  };

  async #checkForWarningMessage() {
      // TODO: refactor into function that parses error messages from the page elements
    let warningBox = await this.page.$('#auth-warning-message-box')
    if (warningBox != null) {
      console.log('found warning box');
      warningMessage = await warningBox.$('.a-list-item')
      // TODO: When capture the captcha image so the browser can run in headless mode
      if (warningMessage.evaluate(node => node.innerText.startsWith('To better protect your account, please re-enter your password'))) {
        console.warn('Captcha challenge required...');
      } else {
        console.error('unanticipated error');
      }
      console.log('Waiting for manual override');
      // continue;
    }
    let alertBox = await this.page.$('#auth-error-message-box');
    if (alertBox != null) {
      console.log('Error detected...');
    }
    // const captcha = reareadlineSyncder.question("Input Captcha: ");
    // if (captcha.toLowerCase() === 'quit') {
    //   await browser.close();
    // }
    // await page.type('[type=password]', 'letmein', { delay: delayTime()})
    // await page.type('[name=guess]', captcha, { delay: delayTime() });

    // await Promise.all([
    //   page.waitForNavigation(),
    //   page.click('[type=submit]', { delay: delayTime() }),
    // ]);

    // <button class="upload-files-link"><span class="label">Upload photos</span><span>Add photos and videos</span></button>
  }

  async #loadCookiesFromFile() {
    if (fs.existsSync('./' + COOKIES_FILENAME)) {
      try {
        const cookies = JSON.parse(fs.readFileSync('./' + COOKIES_FILENAME));
        await this.page.setCookies(...cookies);
        // for (const cookie of cookies) { // setting the cookies individually seems to make puppeteer happy
        //   await this.page.setCookie(cookie);
        // }
      } catch (error) {
        console.log(error);
        exit(1);
      }
    } else {
      console.log('previous cookies not found...');
    }
  };

  /**
   * Returns an object representing the headers that were used to query Amazon's photos API
   * @param {Object} cdpRequestDataRaw returned from setupLoggingOfAllNetworkData(...)
   *
   */
  async #setupLoggingOfAllNetworkData() {
    const cdpSession = await this.page.target().createCDPSession();
    await cdpSession.send('Network.enable');
    const cdpRequestDataRaw = {};
    const addCDPRequestDataListener = (eventName) => {
      cdpSession.on(eventName, (request) => {
        cdpRequestDataRaw[request.requestId] = cdpRequestDataRaw[request.requestId] || {};
        Object.assign(cdpRequestDataRaw[request.requestId], { [eventName]: request });
      });
    };
    addCDPRequestDataListener('Network.requestWillBeSent');
    addCDPRequestDataListener('Network.requestWillBeSentExtraInfo');
    addCDPRequestDataListener('Network.responseReceived');
    addCDPRequestDataListener('Network.responseReceivedExtraInfo');
    return cdpRequestDataRaw;
  }
}
